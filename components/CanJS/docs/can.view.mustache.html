<!DOCTYPE html>

<html>
<head>
  <title>can.view.mustache.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
      <ul id="jump_to">
        <li>
          <a class="large" href="javascript:void(0);">Jump To &hellip;</a>
          <a class="small" href="javascript:void(0);">+</a>
          <div id="jump_wrapper">
          <div id="jump_page">
            
              
              <a class="source" href="can.construct.super.html">
                can.construct.super.js
              </a>
            
              
              <a class="source" href="can.control.plugin.html">
                can.control.plugin.js
              </a>
            
              
              <a class="source" href="can.dojo.html">
                can.dojo.js
              </a>
            
              
              <a class="source" href="can.dojo.min.html">
                can.dojo.min.js
              </a>
            
              
              <a class="source" href="can.fixture.html">
                can.fixture.js
              </a>
            
              
              <a class="source" href="can.jquery.html">
                can.jquery.js
              </a>
            
              
              <a class="source" href="can.jquery.min.html">
                can.jquery.min.js
              </a>
            
              
              <a class="source" href="can.model.queue.html">
                can.model.queue.js
              </a>
            
              
              <a class="source" href="can.mootools.html">
                can.mootools.js
              </a>
            
              
              <a class="source" href="can.mootools.min.html">
                can.mootools.min.js
              </a>
            
              
              <a class="source" href="can.object.html">
                can.object.js
              </a>
            
              
              <a class="source" href="can.observe.attributes.html">
                can.observe.attributes.js
              </a>
            
              
              <a class="source" href="can.observe.backup.html">
                can.observe.backup.js
              </a>
            
              
              <a class="source" href="can.observe.delegate.html">
                can.observe.delegate.js
              </a>
            
              
              <a class="source" href="can.observe.setter.html">
                can.observe.setter.js
              </a>
            
              
              <a class="source" href="can.observe.validations.html">
                can.observe.validations.js
              </a>
            
              
              <a class="source" href="can.util.string.html">
                can.util.string.js
              </a>
            
              
              <a class="source" href="can.view.modifiers.html">
                can.view.modifiers.js
              </a>
            
              
              <a class="source" href="can.view.mustache.html">
                can.view.mustache.js
              </a>
            
              
              <a class="source" href="can.yui.html">
                can.yui.js
              </a>
            
              
              <a class="source" href="can.yui.min.html">
                can.yui.min.js
              </a>
            
              
              <a class="source" href="can.zepto.html">
                can.zepto.js
              </a>
            
              
              <a class="source" href="can.zepto.min.html">
                can.zepto.min.js
              </a>
            
          </div>
        </li>
      </ul>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>can.view.mustache.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              
            </div>
            
            <div class="content"><div class='highlight'><pre><span class="comment">/*!
 * CanJS - 1.1.6
 * http://canjs.us/
 * Copyright (c) 2013 Bitovi
 * Wed, 29 May 2013 18:59:28 GMT
 * Licensed MIT
 * Includes: can/view/mustache
 * Download from: http://canjs.com
 */</span>
(<span class="keyword">function</span>(can) {</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap for-h1">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <h1>mustache.js</h1>
<p><code>can.Mustache</code>: The Mustache templating engine.
See the <a href="#section-29">Transformation</a> section within <em>Scanning Helpers</em> for a detailed explanation 
of the runtime render code design. The majority of the Mustache engine implementation 
occurs within the <em>Transformation</em> scanning helper.</p>
<h2>Initialization</h2>
<p>Define the view extension.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        can.view.ext = <span class="string">".mustache"</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <h3>Setup internal helper variables and functions.</h3>
<p>An alias for the context variable used for tracking a stack of contexts.
This is also used for passing to helper functions to maintain proper context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> CONTEXT = <span class="string">'___c0nt3xt'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>An alias for the variable used for the hash object that can be passed
to helpers via <code>options.hash</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            HASH = <span class="string">'___h4sh'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>An alias for the function that adds a new context to the context stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            STACK = <span class="string">'___st4ck'</span>,
            STACKED = <span class="string">'___st4ck3d'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>An alias for the most used context stacking call.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            CONTEXT_STACK = STACK + <span class="string">'('</span> + CONTEXT + <span class="string">',this)'</span>,
            CONTEXT_OBJ = <span class="string">'{context:'</span> + CONTEXT_STACK + <span class="string">',options:options}'</span>,


            isObserve = <span class="keyword">function</span>(obj) {
                <span class="keyword">return</span> obj !== <span class="literal">null</span> &amp;&amp; can.isFunction(obj.attr) &amp;&amp; obj.constructor &amp;&amp; !! obj.constructor.canMakeObserve;
            },


            isArrayLike = <span class="keyword">function</span>(obj) {
                <span class="keyword">return</span> obj &amp;&amp; obj.splice &amp;&amp; <span class="keyword">typeof</span> obj.length == <span class="string">'number'</span>;
            },</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h2>Mustache</h2>

            </div>
            
            <div class="content"><div class='highlight'><pre>            Mustache = <span class="keyword">function</span>(options, helpers) {</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Support calling Mustache without the constructor.
This returns a function that renders the template.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (<span class="keyword">this</span>.constructor != Mustache) {
                    <span class="keyword">var</span> mustache = <span class="keyword">new</span> Mustache(options);
                    <span class="keyword">return</span> <span class="keyword">function</span>(data, options) {
                        <span class="keyword">return</span> mustache.render(data, options);
                    };
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>If we get a <code>function</code> directly, it probably is coming from
a <code>steal</code>-packaged view.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (<span class="keyword">typeof</span> options == <span class="string">"function"</span>) {
                    <span class="keyword">this</span>.template = {
                        fn: options
                    };
                    <span class="keyword">return</span>;
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>Set options on self.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                can.extend(<span class="keyword">this</span>, options);
                <span class="keyword">this</span>.template = <span class="keyword">this</span>.scanner.scan(<span class="keyword">this</span>.text, <span class="keyword">this</span>.name);
            };</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Put Mustache on the <code>can</code> object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        can.Mustache = window.Mustache = Mustache;


        Mustache.prototype.

        render = <span class="keyword">function</span>(object, options) {
            object = object || {};
            options = options || {};
            <span class="keyword">if</span> (!options.helpers &amp;&amp; !options.partials) {
                options.helpers = options;
            }
            <span class="keyword">return</span> <span class="keyword">this</span>.template.fn.call(object, object, {
                    _data: object,
                    options: options
                });
        };

        can.extend(Mustache.prototype, {</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>Share a singleton scanner for parsing templates.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                scanner: <span class="keyword">new</span> can.view.Scanner({</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>A hash of strings for the scanner to inject at certain points.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        text: {</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>This is the logic to inject at the beginning of a rendered template. 
This includes initializing the <code>context</code> stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            start: <span class="string">'var '</span> + CONTEXT + <span class="string">' = this &amp;&amp; this.'</span> + STACKED + <span class="string">' ? this : [];'</span> + CONTEXT + <span class="string">'.'</span> + STACKED + <span class="string">' = true;'</span> + <span class="string">'var '</span> + STACK + <span class="string">' = function(context, self) {'</span> + <span class="string">'var s;'</span> + <span class="string">'if (arguments.length == 1 &amp;&amp; context) {'</span> + <span class="string">'s = !context.'</span> + STACKED + <span class="string">' ? [context] : context;'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Handle helpers with custom contexts (#228)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            <span class="string">'} else if (!context.'</span> + STACKED + <span class="string">') {'</span> + <span class="string">'s = [self, context];'</span> + <span class="string">'} else if (context &amp;&amp; context === self &amp;&amp; context.'</span> + STACKED + <span class="string">') {'</span> + <span class="string">'s = context.slice(0);'</span> + <span class="string">'} else {'</span> + <span class="string">'s = context &amp;&amp; context.'</span> + STACKED + <span class="string">' ? context.concat([self]) : '</span> + STACK + <span class="string">'(context).concat([self]);'</span> + <span class="string">'}'</span> + <span class="string">'return (s.'</span> + STACKED + <span class="string">' = true) &amp;&amp; s;'</span> + <span class="string">'};'</span>
                        },</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>An ordered token registry for the scanner.
This needs to be ordered by priority to prevent token parsing errors.
Each token follows the following structure:
    [
        // Which key in the token map to match.
        &quot;tokenMapName&quot;,
        // A simple token to match, like &quot;{{&quot;.
        &quot;token&quot;,
        // Optional. A complex (regexp) token to match that 
        // overrides the simple token.
        &quot;[\s\t]*{{&quot;,
        // Optional. A function that executes advanced 
        // manipulation of the matched content. This is 
        // rarely used.
        function(content){<br>            return content;
        }
    ]</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        tokens: [</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>Return unescaped</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            [<span class="string">"returnLeft"</span>, <span class="string">"{{{"</span>, <span class="string">"{{[{&amp;]"</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>Full line comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            [<span class="string">"commentFull"</span>, <span class="string">"{{!}}"</span>, <span class="string">"^[\\s\\t]*{{!.+?}}\\n"</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Inline comments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            [<span class="string">"commentLeft"</span>, <span class="string">"{{!"</span>, <span class="string">"(\\n[\\s\\t]*{{!|{{!)"</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <p>Full line escapes
This is used for detecting lines with only whitespace and an escaped tag</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            [<span class="string">"escapeFull"</span>, <span class="string">"{{}}"</span>, <span class="string">"(^[\\s\\t]*{{[#/^][^}]+?}}\\n|\\n[\\s\\t]*{{[#/^][^}]+?}}\\n|\\n[\\s\\t]*{{[#/^][^}]+?}}$)"</span>,
                                <span class="keyword">function</span>(content) {
                                    <span class="keyword">return</span> {
                                        before: <span class="regexp">/^\n.+?\n$/</span>.test(content) ? <span class="string">'\n'</span> : <span class="string">''</span>,
                                        content: content.match(<span class="regexp">/\{\{(.+?)\}\}/</span>)[<span class="number">1</span>] || <span class="string">''</span>
                                    };
                                }
                            ],</pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>Return escaped</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            [<span class="string">"escapeLeft"</span>, <span class="string">"{{"</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>Close return unescaped</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            [<span class="string">"returnRight"</span>, <span class="string">"}}}"</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>Close tag</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            [<span class="string">"right"</span>, <span class="string">"}}"</span>]
                        ],</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h2>Scanning Helpers</h2>
<p>This is an array of helpers that transform content that is within escaped tags like <code>{{token}}</code>. These helpers are solely for the scanning phase; they are unrelated to Mustache/Handlebars helpers which execute at render time. Each helper has a definition like the following:
    {
        // The content pattern to match in order to execute.
        // Only the first matching helper is executed.
        name: /pattern to match/,
        // The function to transform the content with.
        // @param {String} content   The content to transform.
        // @param {Object} cmd       Scanner helper data.
        //                           {
        //                             insert: &quot;insert command&quot;,
        //                             tagName: &quot;div&quot;,
        //                             status: 0
        //                           }
        fn: function(content, cmd) {
            return &#39;for text injection&#39; || 
                { raw: &#39;to bypass text injection&#39; };
        }
    }</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        helpers: [</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <h3>Partials</h3>
<p>Partials begin with a greater than sign, like {{&gt; box}}.
Partials are rendered at runtime (as opposed to compile time), 
so recursive partials are possible. Just avoid infinite loops.
For example, this template and partial:
        base.mustache:
            <h2>Names</h2>
            {{#names}}
                {{&gt; user}}
            {{/names}}
        user.mustache:
            <strong>{{name}}</strong></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            {
                                name: <span class="regexp">/^&gt;[\s]*\w*/</span>,
                                fn: <span class="keyword">function</span>(content, cmd) {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>Get the template name and call back into the render method,
passing the name and the current context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                    <span class="keyword">var</span> templateName = can.trim(content.replace(<span class="regexp">/^&gt;\s?/</span>, <span class="string">''</span>)).replace(<span class="regexp">/["|']/g</span>, <span class="string">""</span>);
                                    <span class="keyword">return</span> <span class="string">"options.partials &amp;&amp; options.partials['"</span> + templateName + <span class="string">"'] ? can.Mustache.renderPartial(options.partials['"</span> + templateName + <span class="string">"'],"</span> +
                                        CONTEXT_STACK + <span class="string">",options) : can.Mustache.render('"</span> + templateName + <span class="string">"', "</span> + CONTEXT_STACK + <span class="string">")"</span>;
                                }
                            },</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h3>Data Hookup</h3>
<p>This will attach the data property of <code>this</code> to the element
its found on using the first argument as the data attribute
key.
For example:
    <li id="nameli" {{ data 'name' }}></li>
then later you can access it like:
    can.$(&#39;#nameli&#39;).data(&#39;name&#39;);</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            {
                                name: <span class="regexp">/^\s*data\s/</span>,
                                fn: <span class="keyword">function</span>(content, cmd) {
                                    <span class="keyword">var</span> attr = content.match(<span class="regexp">/["|'](.*)["|']/</span>)[<span class="number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>return a function which calls <code>can.data</code> on the element
with the attribute name with the current context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                    <span class="keyword">return</span> <span class="string">"can.proxy(function(__){"</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>&quot;var context = this[this.length-1];&quot; +
&quot;context = context.&quot; + STACKED + &quot; ? context[context.length-2] : context;&quot; +</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                    <span class="string">"can.data(can.$(__),'"</span> + attr + <span class="string">"', this.pop()); }, "</span> + CONTEXT_STACK + <span class="string">")"</span>;
                                }
                            },</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap for-h3">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <h3>Transformation (default)</h3>
<p>This transforms all content to its interpolated equivalent,
including calls to the corresponding helpers as applicable. 
This outputs the render code for almost all cases.</p>
<h4>Definitions</h4>
<ul>
<li><code>context</code> - This is the object that the current rendering context operates within. 
  Each nested template adds a new <code>context</code> to the context stack.</li>
<li><code>stack</code> - Mustache supports nested sections, 
  each of which add their own context to a stack of contexts.
  Whenever a token gets interpolated, it will check for a match against the 
  last context in the stack, then iterate through the rest of the stack checking for matches.
  The first match is the one that gets returned.</li>
<li><code>Mustache.txt</code> - This serializes a collection of logic, optionally contained within a section.
  If this is a simple interpolation, only the interpolation lookup will be passed.
  If this is a section, then an <code>options</code> object populated by the truthy (<code>options.fn</code>) and 
  falsey (<code>options.inverse</code>) encapsulated functions will also be passed. This section handling 
  exists to support the runtime context nesting that Mustache supports.</li>
<li><code>Mustache.get</code> - This resolves an interpolation reference given a stack of contexts.</li>
<li><code>options</code> - An object containing methods for executing the inner contents of sections or helpers.<br>  <code>options.fn</code> - Contains the inner template logic for a truthy section.<br>  <code>options.inverse</code> - Contains the inner template logic for a falsey section.<br>  <code>options.hash</code> - Contains the merged hash object argument for custom helpers.<h4>Design</h4>
This covers the design of the render code that the transformation helper generates.<h5>Pseudocode</h5>
A detailed explanation is provided in the following sections, but here is some brief pseudocode
that gives a high level overview of what the generated render code does (with a template similar to<br><code>&quot;{{#a}}{{b.c.d.e.name}}{{/a}}&quot; == &quot;Phil&quot;</code>).
<em>Initialize the render code.</em><pre><code>  view = []
  context = []
  stack = fn { context.concat([this]) }</code></pre>
<em>Render the root section.</em><pre><code>  view.push( &quot;string&quot; )
  view.push( can.view.txt(</code></pre>
<em>Render the nested section with <code>can.Mustache.txt</code>.</em><pre><code>      txt( </code></pre>
<em>Add the current context to the stack.</em><pre><code>          stack(), </code></pre>
<em>Flag this for truthy section mode.</em><pre><code>          &quot;#&quot;,</code></pre>
<em>Interpolate and check the <code>a</code> variable for truthyness using the stack with <code>can.Mustache.get</code>.</em><pre><code>          get( &quot;a&quot;, stack() ),</code></pre>
<em>Include the nested section&#39;s inner logic.
The stack argument is usually the parent section&#39;s copy of the stack, 
but it can be an override context that was passed by a custom helper.
Sections can nest <code>0..n</code> times -- <strong>NESTCEPTION</strong>.</em><pre><code>          { fn: fn(stack) {</code></pre>
<em>Render the nested section (everything between the <code>{{#a}}</code> and <code>{{/a}}</code> tokens).</em><pre><code>              view = []
              view.push( &quot;string&quot; )
              view.push(</code></pre>
<em>Add the current context to the stack.</em><pre><code>                  stack(),</code></pre>
<em>Flag this as interpolation-only mode.</em><pre><code>                  null,</code></pre>
<em>Interpolate the <code>b.c.d.e.name</code> variable using the stack.</em><pre><code>                  get( &quot;b.c.d.e.name&quot;, stack() ),
              )
              view.push( &quot;string&quot; )</code></pre>
<em>Return the result for the nested section.</em><pre><code>              return view.join()
          }}
      )
  ))
  view.push( &quot;string&quot; )</code></pre>
<em>Return the result for the root section, which includes all nested sections.</em><pre><code>  return view.join()</code></pre>
<h5>Initialization</h5>
Each rendered template is started with the following initialization code:<pre><code>  var ___v1ew = [];
  var ___c0nt3xt = [];
  ___c0nt3xt.___st4ck = true;
  var ___st4ck = function(context, self) {
      var s;
      if (arguments.length == 1 &amp;&amp; context) {
          s = !context.___st4ck ? [context] : context;
      } else {
          s = context &amp;&amp; context.___st4ck 
          ? context.concat([self]) 
          : ___st4ck(context).concat([self]);
      }
      return (s.___st4ck = true) &amp;&amp; s;
  };</code></pre>
The <code>___v1ew</code> is the the array used to serialize the view.
The <code>___c0nt3xt</code> is a stacking array of contexts that slices and expands with each nested section.
The <code>___st4ck</code> function is used to more easily update the context stack in certain situations.
Usually, the stack function simply adds a new context (<code>self</code>/<code>this</code>) to a context stack. 
However, custom helpers will occasionally pass override contexts that need their own context stack.<h5>Sections</h5>
Each section, <code>{{#section}} content {{/section}}</code>, within a Mustache template generates a section 
context in the resulting render code. The template itself is treated like a root section, with the 
same execution logic as any others. Each section can have <code>0..n</code> nested sections within it.
Here&#39;s an example of a template without any descendent sections.<br>Given the template: <code>&quot;{{a.b.c.d.e.name}}&quot; == &quot;Phil&quot;</code><br>Would output the following render code:
  <strong><em>v1ew.push(&quot;\&quot;&quot;);
  </em></strong>v1ew.push(can.view.txt(1, &#39;&#39;, 0, this, function() {<pre><code>      return can.Mustache.txt(___st4ck(___c0nt3xt, this), null, 
      can.Mustache.get(&quot;a.b.c.d.e.name&quot;, 
          ___st4ck(___c0nt3xt, this))
  );</code></pre>
  }));
  <strong><em>v1ew.push(&quot;\&quot; == \&quot;Phil\&quot;&quot;);
The simple strings will get appended to the view. Any interpolated references (like <code>{{a.b.c.d.e.name}}</code>) 
will be pushed onto the view via <code>can.view.txt</code> in order to support live binding.
The function passed to <code>can.view.txt</code> will call <code>can.Mustache.txt</code>, which serializes the object data by doing 
a context lookup with <code>can.Mustache.get</code>.
<code>can.Mustache.txt</code>&#39;s first argument is a copy of the context stack with the local context <code>this</code> added to it.
This stack will grow larger as sections nest.
The second argument is for the section type. This will be <code>&quot;#&quot;</code> for truthy sections, <code>&quot;^&quot;</code> for falsey, 
or <code>null</code> if it is an interpolation instead of a section.
The third argument is the interpolated value retrieved with <code>can.Mustache.get</code>, which will perform the 
context lookup and return the approriate string or object.
Any additional arguments, if they exist, are used for passing arguments to custom helpers.
For nested sections, the last argument is an <code>options</code> object that contains the nested section&#39;s logic.
Here&#39;s an example of a template with a single nested section.<br>Given the template: <code>&quot;{{#a}}{{b.c.d.e.name}}{{/a}}&quot; == &quot;Phil&quot;</code><br>Would output the following render code:
  </em></strong>v1ew.push(&quot;\&quot;&quot;);<pre><code>  ___v1ew.push(can.view.txt(0, &#39;&#39;, 0, this, function() {
      return can.Mustache.txt(___st4ck(___c0nt3xt, this), &quot;#&quot;, 
      can.Mustache.get(&quot;a&quot;, ___st4ck(___c0nt3xt, this)), 
          [{
              _: function() {
                  return ___v1ew.join(&quot;&quot;);
              }
          }, {
              fn: function(___c0nt3xt) {
                  var ___v1ew = [];
                  ___v1ew.push(can.view.txt(1, &#39;&#39;, 0, this, 
                      function() {
                           return can.Mustache.txt(
                              ___st4ck(___c0nt3xt, this), 
                              null, 
                              can.Mustache.get(&quot;b.c.d.e.name&quot;, 
                                  ___st4ck(___c0nt3xt, this))
                          );
                      }
                  ));
                  return ___v1ew.join(&quot;&quot;);
              }
          }]
  )
  }));</code></pre>
  <strong><em>v1ew.push(&quot;\&quot; == \&quot;Phil\&quot;&quot;);
This is specified as a truthy section via the <code>&quot;#&quot;</code> argument. The last argument includes an array of helper methods used with <code>options</code>.
These act similarly to custom helpers: <code>options.fn</code> will be called for truthy sections, <code>options.inverse</code> will be called for falsey sections.
The `options.</em><code>function only exists as a dummy function to make generating the section nesting easier (a section may have a</code>fn<code>,</code>inverse<code>,
or both, but there isn&#39;t any way to determine that at compilation time).
Within the</code>fn<code>function is the section&#39;s render context, which in this case will render anything between the</code>{{#a}}<code>and</code>{{/a}}<code>tokens.
This function has</code>_</strong>c0nt3xt<code>as an argument because custom helpers can pass their own override contexts. For any case where custom helpers
aren&#39;t used,</code><strong><em>c0nt3xt<code>will be equivalent to the</code></em></strong>st4ck(<strong><em>c0nt3xt, this)<code>stack created by its parent section. The</code>inverse<code>function
works similarly, except that it is added when</code>{{^a}}<code>and</code>{{else}}<code>are used.</code>var </em></strong>v1ew = []<code>is specified in</code>fn<code>and</code>inverse<code>to 
ensure that live binding in nested sections works properly.
All of these nested sections will combine to return a compiled string that functions similar to EJS in its uses of</code>can.view.txt`.<h4>Implementation</h4>
</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            {
                                name: <span class="regexp">/^.*$/</span>,
                                fn: <span class="keyword">function</span>(content, cmd) {
                                    <span class="keyword">var</span> mode = <span class="literal">false</span>,
                                        result = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>Trim the content so we don&#39;t have any trailing whitespace.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                    content = can.trim(content);</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>Determine what the active mode is.
<em> <code>#</code> - Truthy section
</em> <code>^</code> - Falsey section
<em> <code>/</code> - Close the prior section
</em> <code>else</code> - Inverted section (only exists within a truthy/falsey section)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                    <span class="keyword">if</span> (content.length &amp;&amp; (mode = content.match(<span class="regexp">/^([#^/</span>]|<span class="keyword">else</span>$)/))) {
                                        mode = mode[<span class="number">0</span>];
                                        <span class="keyword">switch</span> (mode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>Open a new section.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                            <span class="keyword">case</span> <span class="string">'#'</span>:
                                            <span class="keyword">case</span> <span class="string">'^'</span>:
                                                result.push(cmd.insert + <span class="string">'can.view.txt(0,\''</span> + cmd.tagName + <span class="string">'\','</span> + cmd.status + <span class="string">',this,function(){ return '</span>);
                                                <span class="keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>Close the prior section.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                            <span class="keyword">case</span> <span class="string">'/'</span>:
                                                <span class="keyword">return</span> {
                                                    raw: <span class="string">'return ___v1ew.join("");}}])}));'</span>
                                                };
                                                <span class="keyword">break</span>;
                                        }</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>Trim the mode off of the content.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                        content = content.substring(<span class="number">1</span>);
                                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p><code>else</code> helpers are special and should be skipped since they don&#39;t 
have any logic aside from kicking off an <code>inverse</code> function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                    <span class="keyword">if</span> (mode != <span class="string">'else'</span>) {
                                        <span class="keyword">var</span> args = [],
                                            i = <span class="number">0</span>,
                                            hashing = <span class="literal">false</span>,
                                            arg, split, m;</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>Parse the helper arguments.
This needs uses this method instead of a split(/\s/) so that 
strings with spaces can be correctly parsed.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                        (can.trim(content) + <span class="string">' '</span>).replace(<span class="regexp">/((([^\s]+?=)?('.*?'|".*?"))|.*?)\s/g</span>, <span class="keyword">function</span>(whole, part) {
                                                args.push(part);
                                            });</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>Start the content render block.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                        result.push(<span class="string">'can.Mustache.txt('</span> + CONTEXT_OBJ + <span class="string">','</span> + (mode ? <span class="string">'"'</span> + mode + <span class="string">'"'</span> : <span class="string">'null'</span>) + <span class="string">','</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>Iterate through the helper arguments, if there are any.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                        <span class="keyword">for</span> (; arg = args[i]; i++) {
                                            i &amp;&amp; result.push(<span class="string">','</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>Check for special helper arguments (string/number/boolean/hashes).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                            <span class="keyword">if</span> (i &amp;&amp; (m = arg.match(<span class="regexp">/^(('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false)|((.+?)=(('.*?'|".*?"|[0-9]+\.?[0-9]*|true|false)|(.+))))$/</span>))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>Found a native type like string/number/boolean.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                                <span class="keyword">if</span> (m[<span class="number">2</span>]) {
                                                    result.push(m[<span class="number">0</span>]);
                                                }</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>Found a hash object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                                <span class="keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p>Open the hash object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                                    <span class="keyword">if</span> (!hashing) {
                                                        hashing = <span class="literal">true</span>;
                                                        result.push(<span class="string">'{'</span> + HASH + <span class="string">':{'</span>);
                                                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>Add the key/value.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                                    result.push(m[<span class="number">4</span>], <span class="string">':'</span>, m[<span class="number">6</span>] ? m[<span class="number">6</span>] : <span class="string">'can.Mustache.get("'</span> + m[<span class="number">5</span>].replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>) + <span class="string">'",'</span> + CONTEXT_OBJ + <span class="string">')'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>Close the hash if this was the last argument.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                                    <span class="keyword">if</span> (i == args.length - <span class="number">1</span>) {
                                                        result.push(<span class="string">'}}'</span>);
                                                    }
                                                }
                                            }</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>Otherwise output a normal interpolation reference.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                            <span class="keyword">else</span> {
                                                result.push(<span class="string">'can.Mustache.get("'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>Include the reference name.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                                    arg.replace(<span class="regexp">/"/g</span>, <span class="string">'\\"'</span>) + <span class="string">'",'</span> +</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>Then the stack of context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                                    CONTEXT_OBJ +</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>Flag as a helper method to aid performance, 
if it is a known helper (anything with &gt; 0 arguments).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                                    (i == <span class="number">0</span> &amp;&amp; args.length &gt; <span class="number">1</span> ? <span class="string">',true'</span> : <span class="string">',false'</span>) +
                                                    (i &gt; <span class="number">0</span> ? <span class="string">',true'</span> : <span class="string">',false'</span>) +
                                                    <span class="string">')'</span>);
                                            }
                                        }
                                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>Create an option object for sections of code.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                    mode &amp;&amp; mode != <span class="string">'else'</span> &amp;&amp; result.push(<span class="string">',[{_:function(){'</span>);
                                    <span class="keyword">switch</span> (mode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>Truthy section</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                        <span class="keyword">case</span> <span class="string">'#'</span>:
                                            result.push(<span class="string">'return ___v1ew.join("");}},{fn:function('</span> + CONTEXT + <span class="string">'){var ___v1ew = [];'</span>);
                                            <span class="keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <p>If/else section
Falsey section</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                        <span class="keyword">case</span> <span class="string">'else'</span>:
                                        <span class="keyword">case</span> <span class="string">'^'</span>:
                                            result.push(<span class="string">'return ___v1ew.join("");}},{inverse:function('</span> + CONTEXT + <span class="string">'){var ___v1ew = [];'</span>);
                                            <span class="keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Not a section</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                        <span class="keyword">default</span>:
                                            result.push(<span class="string">');'</span>);
                                            <span class="keyword">break</span>;
                                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>Return a raw result if there was a section, otherwise return the default string.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                    result = result.join(<span class="string">''</span>);
                                    <span class="keyword">return</span> mode ? {
                                        raw: result
                                    } : result;
                                }
                            }
                        ]
                    })
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>Add in default scanner helpers first.
We could probably do this differently if we didn&#39;t &#39;break&#39; on every match.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="keyword">var</span> helpers = can.view.Scanner.prototype.helpers;
        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; helpers.length; i++) {
            Mustache.prototype.scanner.helpers.unshift(helpers[i]);
        };


        Mustache.txt = <span class="keyword">function</span>(context, mode, name) {</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>Grab the extra arguments to pass to helpers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> args = Array.prototype.slice.call(arguments, <span class="number">3</span>),</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>Create a default <code>options</code> object to pass to the helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                options = can.extend.apply(can, [{
                            fn: <span class="keyword">function</span>() {},
                            inverse: <span class="keyword">function</span>() {}
                        }
                    ].concat(mode ? args.pop() : []));


            <span class="keyword">var</span> extra = {};
            <span class="keyword">if</span> (context.context) {
                extra = context.options;
                context = context.context;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>Check for a registered helper or a helper-like function.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (helper = (Mustache.getHelper(name, extra) || (can.isFunction(name) &amp;&amp; !name.isComputed &amp;&amp; {
                            fn: name
                        }))) {</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>Use the most recent context as <code>this</code> for the helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">var</span> stack = context[STACKED] &amp;&amp; context,
                    context = (stack &amp;&amp; context[context.length - <span class="number">1</span>]) || context,</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>Update the options with a function/inverse (the inner templates of a section).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    opts = {
                        fn: can.proxy(options.fn, context),
                        inverse: can.proxy(options.inverse, context)
                    },
                    lastArg = args[args.length - <span class="number">1</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>Store the context stack in the options if one exists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (stack) {
                    opts.contexts = stack;
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>Add the hash to <code>options</code> if one exists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (lastArg &amp;&amp; lastArg[HASH]) {
                    opts.hash = args.pop()[HASH];
                }
                args.push(opts);</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>Call the helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">return</span> helper.fn.apply(context, args) || <span class="string">''</span>;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>if a compute, get the value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (can.isFunction(name) &amp;&amp; name.isComputed) {
                name = name();
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>An array of arguments to check for truthyness when evaluating sections.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> validArgs = args.length ? args : [name],</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>Whether the arguments meet the condition of the section.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                valid = <span class="literal">true</span>,
                result = [],
                i, helper, argIsObserve, arg;</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>Validate the arguments based on the section mode.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (mode) {
                <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; validArgs.length; i++) {
                    arg = validArgs[i];
                    argIsObserve = <span class="keyword">typeof</span> arg !== <span class="string">'undefined'</span> &amp;&amp; isObserve(arg);</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>Array-like objects are falsey if their length = 0.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">if</span> (isArrayLike(arg)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>Use .attr to trigger binding on empty lists returned from function</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        <span class="keyword">if</span> (mode == <span class="string">'#'</span>) {
                            valid = valid &amp;&amp; !! (argIsObserve ? arg.attr(<span class="string">'length'</span>) : arg.length);
                        } <span class="keyword">else</span> <span class="keyword">if</span> (mode == <span class="string">'^'</span>) {
                            valid = valid &amp;&amp; !(argIsObserve ? arg.attr(<span class="string">'length'</span>) : arg.length);
                        }
                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>Otherwise just check if it is truthy or not.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">else</span> {
                        valid = mode == <span class="string">'#'</span> ? valid &amp;&amp; !! arg : mode == <span class="string">'^'</span> ? valid &amp;&amp; !arg : valid;
                    }
                }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>Otherwise interpolate like normal.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (valid) {
                <span class="keyword">switch</span> (mode) {</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>Truthy section.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">case</span> <span class="string">'#'</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>Iterate over arrays</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        <span class="keyword">if</span> (isArrayLike(name)) {
                            <span class="keyword">var</span> isObserveList = isObserve(name);</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>Add the reference to the list in the contexts.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; name.length; i++) {
                                result.push(options.fn.call(name[i], context) || <span class="string">''</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>Ensure that live update works on observable lists</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                                isObserveList &amp;&amp; name.attr(<span class="string">''</span> + i);
                            }
                            <span class="keyword">return</span> result.join(<span class="string">''</span>);
                        }</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>Normal case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        <span class="keyword">else</span> {
                            <span class="keyword">return</span> options.fn.call(name || {}, context) || <span class="string">''</span>;
                        }
                        <span class="keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>Falsey section.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">case</span> <span class="string">'^'</span>:
                        <span class="keyword">return</span> options.inverse.call(name || {}, context) || <span class="string">''</span>;
                        <span class="keyword">break</span>;
                    <span class="keyword">default</span>:</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>Add + &#39;&#39; to convert things like numbers to strings.
This can cause issues if you are trying to
eval on the length but this is the more
common case.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                        <span class="keyword">return</span> <span class="string">''</span> + (name !== <span class="literal">undefined</span> ? name : <span class="string">''</span>);
                        <span class="keyword">break</span>;
                }
            }

            <span class="keyword">return</span> <span class="string">''</span>;
        };


        Mustache.get = <span class="keyword">function</span>(ref, contexts, isHelper, isArgument) {
            <span class="keyword">var</span> options = contexts.options || {};
            contexts = contexts.context || contexts;</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>Assume the local object is the last context in the stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">var</span> obj = contexts[contexts.length - <span class="number">1</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>Assume the parent context is the second to last context in the stack.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                context = contexts[contexts.length - <span class="number">2</span>],</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>Split the reference (like <code>a.b.c</code>) into an array of key names.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                names = ref.indexOf(<span class="string">'\\.'</span>) == -<span class="number">1</span></pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>Reference doesn&#39;t contain escaped periods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                ? ref.split(<span class="string">'.'</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>Reference contains escaped periods (<code>a.b\c.foo</code> == `a[&quot;b.c&quot;].foo)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                : (<span class="keyword">function</span>() {
                        <span class="keyword">var</span> names = [],
                            last = <span class="number">0</span>;
                        ref.replace(<span class="regexp">/(\\)?\./g</span>, <span class="keyword">function</span>($<span class="number">0</span>, $<span class="number">1</span>, index) {
                                <span class="keyword">if</span> (!$<span class="number">1</span>) {
                                    names.push(ref.slice(last, index).replace(<span class="regexp">/\\\./g</span>, <span class="string">'.'</span>));
                                    last = index + $<span class="number">0.</span>length;
                                }
                            });
                        names.push(ref.slice(last).replace(<span class="regexp">/\\\./g</span>, <span class="string">'.'</span>));
                        <span class="keyword">return</span> names;
                    })(),
                namesLength = names.length,
                value, lastValue, name, i, j,</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>if we walk up and don&#39;t find a property, we default
to listening on an undefined property of the first
context that is an observe</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                defaultObserve,
                defaultObserveName;</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>Handle <code>this</code> references for list iteration: {{.}} or {{this}}</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (<span class="regexp">/^\.|this$/</span>.test(ref)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>If context isn&#39;t an object, then it was a value passed by a helper so use it as an override.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (!<span class="regexp">/^object|undefined$/</span>.test(<span class="keyword">typeof</span> context)) {
                    <span class="keyword">return</span> context || <span class="string">''</span>;
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>Otherwise just return the closest object.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">else</span> {
                    <span class="keyword">while</span> (value = contexts.pop()) {
                        <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'undefined'</span>) {
                            <span class="keyword">return</span> value;
                        }
                    }
                    <span class="keyword">return</span> <span class="string">''</span>;
                }
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>Handle object resolution (like <code>a.b.c</code>).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">else</span> <span class="keyword">if</span> (!isHelper) {</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>Reverse iterate through the contexts (last in, first out).</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">for</span> (i = contexts.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) {</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>Check the context for the reference</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    value = contexts[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p>Is the value a compute?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">if</span> (can.isFunction(value) &amp;&amp; value.isComputed) {
                        value = value();
                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>Make sure the context isn&#39;t a failed object before diving into it.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">if</span> (<span class="keyword">typeof</span> value !== <span class="string">'undefined'</span> &amp;&amp; value !== <span class="literal">null</span>) {
                        <span class="keyword">var</span> isHelper = Mustache.getHelper(ref, options);
                        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; namesLength; j++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>Keep running up the tree while there are matches.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            <span class="keyword">if</span> (<span class="keyword">typeof</span> value[names[j]] !== <span class="string">'undefined'</span> &amp;&amp; value[names[j]] !== <span class="literal">null</span>) {
                                lastValue = value;
                                value = value[name = names[j]];
                            }</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>if there&#39;s a name conflict between property and helper
property wins</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            <span class="keyword">else</span> <span class="keyword">if</span> (isHelper) {
                                <span class="keyword">return</span> ref;
                            }</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>If it&#39;s undefined, still match if the parent is an Observe.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                            <span class="keyword">else</span> <span class="keyword">if</span> (isObserve(value)) {
                                defaultObserve = value;
                                defaultObserveName = names[j];
                                lastValue = value = <span class="literal">undefined</span>;
                                <span class="keyword">break</span>;
                            } <span class="keyword">else</span> {
                                lastValue = value = <span class="literal">undefined</span>;
                                <span class="keyword">break</span>;
                            }
                        }
                    }</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>Found a matched reference.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                    <span class="keyword">if</span> (value !== <span class="literal">undefined</span>) {
                        <span class="keyword">return</span> Mustache.resolve(value, lastValue, name, isArgument);
                    }
                }
            }

            <span class="keyword">if</span> (defaultObserve &amp;&amp;</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>if there&#39;s not a helper by this name and no attribute with this name</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                !(Mustache.getHelper(ref) &amp;&amp;
                    can.inArray(defaultObserveName, can.Observe.keys(defaultObserve)) === -<span class="number">1</span>)) {
                <span class="keyword">return</span> defaultObserve.compute(defaultObserveName);
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <p>Support helpers without arguments, but only if there wasn&#39;t a matching data reference.
Helpers have priority over local function, see <a href="https://github.com/bitovi/canjs/issues/258">https://github.com/bitovi/canjs/issues/258</a></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (value = Mustache.getHelper(ref, options)) {
                <span class="keyword">return</span> ref;
            } <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> obj !== <span class="string">'undefined'</span> &amp;&amp; obj !== <span class="literal">null</span> &amp;&amp; can.isFunction(obj[ref])) {</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <p>Support helper-like functions as anonymous helpers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">return</span> obj[ref];
            }

            <span class="keyword">return</span> <span class="string">''</span>;
        };


        Mustache.resolve = <span class="keyword">function</span>(value, lastValue, name, isArgument) {
            <span class="keyword">if</span> (lastValue &amp;&amp; can.isFunction(lastValue[name]) &amp;&amp; isArgument) {
                <span class="keyword">if</span> (lastValue[name].isComputed) {
                    <span class="keyword">return</span> lastValue[name];
                }</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>Don&#39;t execute functions if they are parameters for a helper and are not a can.compute
Need to bind it to the original context so that that information doesn&#39;t get lost by the helper</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">return</span> <span class="keyword">function</span>() {
                    <span class="keyword">return</span> lastValue[name].apply(lastValue, arguments);
                };
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p>Support attributes on compute objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">else</span> <span class="keyword">if</span> (lastValue &amp;&amp; can.isFunction(lastValue) &amp;&amp; lastValue.isComputed) {
                <span class="keyword">return</span> lastValue()[name];
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>Support functions stored in objects.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">else</span> <span class="keyword">if</span> (lastValue &amp;&amp; can.isFunction(lastValue[name])) {
                <span class="keyword">return</span> lastValue[name]();
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>Invoke the length to ensure that Observe.List events fire.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">else</span> <span class="keyword">if</span> (isObserve(value) &amp;&amp; isArrayLike(value) &amp;&amp; value.attr(<span class="string">'length'</span>)) {
                <span class="keyword">return</span> value;
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>Add support for observes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">else</span> <span class="keyword">if</span> (lastValue &amp;&amp; isObserve(lastValue)) {
                <span class="keyword">return</span> lastValue.compute(name);
            } <span class="keyword">else</span> <span class="keyword">if</span> (can.isFunction(value)) {
                <span class="keyword">return</span> value();
            } <span class="keyword">else</span> {
                <span class="keyword">return</span> value;
            }
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <h2>Helpers</h2>
<p>Helpers are functions that can be called from within a template.
These helpers differ from the scanner helpers in that they execute
at runtime instead of during compilation.
Custom helpers can be added via <code>can.Mustache.registerHelper</code>,
but there are also some built-in helpers included by default.
Most of the built-in helpers are little more than aliases to actions 
that the base version of Mustache simply implies based on the 
passed in object.
Built-in helpers:
<em> <code>data</code> - <code>data</code> is a special helper that is implemented via scanning helpers. 
    It hooks up the active element to the active data object: <code>&lt;div {{data &quot;key&quot;}} /&gt;</code>
</em> <code>if</code> - Renders a truthy section: <code>{{#if var}} render {{/if}}</code>
<em> <code>unless</code> - Renders a falsey section: <code>{{#unless var}} render {{/unless}}</code>
</em> <code>each</code> - Renders an array: <code>{{#each array}} render {{this}} {{/each}}</code>
* <code>with</code> - Opens a context section: <code>{{#with var}} render {{/with}}</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        Mustache._helpers = {};

        Mustache.registerHelper = <span class="keyword">function</span>(name, fn) {
            <span class="keyword">this</span>._helpers[name] = {
                name: name,
                fn: fn
            };
        };


        Mustache.getHelper = <span class="keyword">function</span>(name, options) {
            <span class="keyword">return</span> options &amp;&amp; options.helpers &amp;&amp; options.helpers[name] &amp;&amp; {
                fn: options.helpers[name]
            } || <span class="keyword">this</span>._helpers[name]
            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, helper; helper = [i]; i++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>Find the correct helper</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="keyword">if</span> (helper.name == name) {
                    <span class="keyword">return</span> helper;
                }
            }
            <span class="keyword">return</span> <span class="literal">null</span>;
        };


        Mustache.render = <span class="keyword">function</span>(partial, context) {</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>Make sure the partial being passed in
isn&#39;t a variable like { partial: &quot;foo.mustache&quot; }</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">if</span> (!can.view.cached[partial] &amp;&amp; context[partial]) {
                partial = context[partial];
            }</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>Call into <code>can.view.render</code> passing the
partial and context.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>            <span class="keyword">return</span> can.view.render(partial, context);
        };

        Mustache.renderPartial = <span class="keyword">function</span>(partial, context, options) {
            <span class="keyword">return</span> partial.render ? partial.render(context, options) :
                partial(context, options);
        };</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>The built-in Mustache helpers.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        can.each({</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>Implements the <code>if</code> built-in helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="string">'if'</span>: <span class="keyword">function</span>(expr, options) {
                    <span class="keyword">if</span> ( !! Mustache.resolve(expr)) {
                        <span class="keyword">return</span> options.fn(options.contexts || <span class="keyword">this</span>);
                    } <span class="keyword">else</span> {
                        <span class="keyword">return</span> options.inverse(options.contexts || <span class="keyword">this</span>);
                    }
                },</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>Implements the <code>unless</code> built-in helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="string">'unless'</span>: <span class="keyword">function</span>(expr, options) {
                    <span class="keyword">if</span> (!Mustache.resolve(expr)) {
                        <span class="keyword">return</span> options.fn(options.contexts || <span class="keyword">this</span>);
                    }
                },</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>Implements the <code>each</code> built-in helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="string">'each'</span>: <span class="keyword">function</span>(expr, options) {
                    expr = Mustache.resolve(expr);
                    <span class="keyword">if</span> ( !! expr &amp;&amp; isArrayLike(expr)) {
                        <span class="keyword">if</span> (isObserve(expr) &amp;&amp; expr.attr(<span class="string">'length'</span>)) {
                            <span class="keyword">return</span> can.view.lists &amp;&amp; can.view.lists(expr, <span class="keyword">function</span>(item) {
                                    <span class="keyword">return</span> options.fn(item);
                                });
                        } <span class="keyword">else</span> {
                            <span class="keyword">var</span> result = [];
                            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; expr.length; i++) {
                                result.push(options.fn(expr[i]));
                            }
                            <span class="keyword">return</span> result.join(<span class="string">''</span>);
                        }
                    }
                },</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>Implements the <code>with</code> built-in helper.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                <span class="string">'with'</span>: <span class="keyword">function</span>(expr, options) {
                    <span class="keyword">var</span> ctx = expr;
                    expr = Mustache.resolve(expr);
                    <span class="keyword">if</span> ( !! expr) {
                        <span class="keyword">return</span> options.fn(ctx);
                    }
                }

            }, <span class="keyword">function</span>(fn, name) {
                Mustache.registerHelper(name, fn);
            });</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap for-h2">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <h2>Registration</h2>
<p>Registers Mustache with can.view.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        can.view.register({
                suffix: <span class="string">"mustache"</span>,

                contentType: <span class="string">"x-mustache-template"</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>Returns a <code>function</code> that renders the view.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>                script: <span class="keyword">function</span>(id, src) {
                    <span class="keyword">return</span> <span class="string">"can.Mustache(function(_CONTEXT,_VIEW) { "</span> + <span class="keyword">new</span> Mustache({
                            text: src,
                            name: id
                        }).template.out + <span class="string">" })"</span>;
                },

                renderer: <span class="keyword">function</span>(id, text) {
                    <span class="keyword">return</span> Mustache({
                            text: text,
                            name: id
                        });
                }
            });

        <span class="keyword">return</span> can;
    })(can);</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
